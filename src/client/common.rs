// Autogenerated by Thrift Compiler (0.14.1)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TConsensusGroupType {
  ConfigRegion = 0,
  DataRegion = 1,
  SchemaRegion = 2,
}

impl TConsensusGroupType {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TConsensusGroupType> {
    let enum_value = i_prot.read_i32()?;
    TConsensusGroupType::try_from(enum_value)  }
}

impl TryFrom<i32> for TConsensusGroupType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TConsensusGroupType::ConfigRegion),
      1 => Ok(TConsensusGroupType::DataRegion),
      2 => Ok(TConsensusGroupType::SchemaRegion),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TConsensusGroupType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TRegionMigrateFailedType {
  AddPeerFailed = 0,
  RemovePeerFailed = 1,
  RemoveConsensusGroupFailed = 2,
  DeleteRegionFailed = 3,
  CreateRegionFailed = 4,
  Disconnect = 5,
}

impl TRegionMigrateFailedType {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRegionMigrateFailedType> {
    let enum_value = i_prot.read_i32()?;
    TRegionMigrateFailedType::try_from(enum_value)  }
}

impl TryFrom<i32> for TRegionMigrateFailedType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TRegionMigrateFailedType::AddPeerFailed),
      1 => Ok(TRegionMigrateFailedType::RemovePeerFailed),
      2 => Ok(TRegionMigrateFailedType::RemoveConsensusGroupFailed),
      3 => Ok(TRegionMigrateFailedType::DeleteRegionFailed),
      4 => Ok(TRegionMigrateFailedType::CreateRegionFailed),
      5 => Ok(TRegionMigrateFailedType::Disconnect),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TRegionMigrateFailedType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TRegionMaintainTaskStatus {
  TaskNotExist = 0,
  Processing = 1,
  Success = 2,
  Fail = 3,
}

impl TRegionMaintainTaskStatus {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRegionMaintainTaskStatus> {
    let enum_value = i_prot.read_i32()?;
    TRegionMaintainTaskStatus::try_from(enum_value)  }
}

impl TryFrom<i32> for TRegionMaintainTaskStatus {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TRegionMaintainTaskStatus::TaskNotExist),
      1 => Ok(TRegionMaintainTaskStatus::Processing),
      2 => Ok(TRegionMaintainTaskStatus::Success),
      3 => Ok(TRegionMaintainTaskStatus::Fail),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TRegionMaintainTaskStatus", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ThrottleType {
  RequestNumber = 0,
  RequestSize = 1,
  WriteNumber = 2,
  WriteSize = 3,
  ReadNumber = 4,
  ReadSize = 5,
}

impl ThrottleType {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ThrottleType> {
    let enum_value = i_prot.read_i32()?;
    ThrottleType::try_from(enum_value)  }
}

impl TryFrom<i32> for ThrottleType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ThrottleType::RequestNumber),
      1 => Ok(ThrottleType::RequestSize),
      2 => Ok(ThrottleType::WriteNumber),
      3 => Ok(ThrottleType::WriteSize),
      4 => Ok(ThrottleType::ReadNumber),
      5 => Ok(ThrottleType::ReadSize),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ThrottleType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TAggregationType {
  Count = 0,
  Avg = 1,
  Sum = 2,
  FirstValue = 3,
  LastValue = 4,
  MaxTime = 5,
  MinTime = 6,
  MaxValue = 7,
  MinValue = 8,
  Extreme = 9,
  CountIf = 10,
  TimeDuration = 11,
  Mode = 12,
  CountTime = 13,
  Stddev = 14,
  StddevPop = 15,
  StddevSamp = 16,
  Variance = 17,
  VarPop = 18,
  VarSamp = 19,
  MaxBy = 20,
  MinBy = 21,
  Udaf = 22,
}

impl TAggregationType {
  pub fn write_to_out_protocol(self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TAggregationType> {
    let enum_value = i_prot.read_i32()?;
    TAggregationType::try_from(enum_value)  }
}

impl TryFrom<i32> for TAggregationType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(TAggregationType::Count),
      1 => Ok(TAggregationType::Avg),
      2 => Ok(TAggregationType::Sum),
      3 => Ok(TAggregationType::FirstValue),
      4 => Ok(TAggregationType::LastValue),
      5 => Ok(TAggregationType::MaxTime),
      6 => Ok(TAggregationType::MinTime),
      7 => Ok(TAggregationType::MaxValue),
      8 => Ok(TAggregationType::MinValue),
      9 => Ok(TAggregationType::Extreme),
      10 => Ok(TAggregationType::CountIf),
      11 => Ok(TAggregationType::TimeDuration),
      12 => Ok(TAggregationType::Mode),
      13 => Ok(TAggregationType::CountTime),
      14 => Ok(TAggregationType::Stddev),
      15 => Ok(TAggregationType::StddevPop),
      16 => Ok(TAggregationType::StddevSamp),
      17 => Ok(TAggregationType::Variance),
      18 => Ok(TAggregationType::VarPop),
      19 => Ok(TAggregationType::VarSamp),
      20 => Ok(TAggregationType::MaxBy),
      21 => Ok(TAggregationType::MinBy),
      22 => Ok(TAggregationType::Udaf),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TAggregationType", i)
            )
          )
        )
      },
    }
  }
}

//
// TEndPoint
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TEndPoint {
  pub ip: String,
  pub port: i32,
}

impl TEndPoint {
  pub fn new(ip: String, port: i32) -> TEndPoint {
    TEndPoint {
      ip,
      port,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TEndPoint> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TEndPoint.ip", &f_1)?;
    verify_required_field_exists("TEndPoint.port", &f_2)?;
    let ret = TEndPoint {
      ip: f_1.expect("auto-generated code should have checked for presence of required fields"),
      port: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TEndPoint");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ip", TType::String, 1))?;
    o_prot.write_string(&self.ip)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("port", TType::I32, 2))?;
    o_prot.write_i32(self.port)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSStatus
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSStatus {
  pub code: i32,
  pub message: Option<String>,
  pub sub_status: Option<Vec<Box<TSStatus>>>,
  pub redirect_node: Option<TEndPoint>,
  pub need_retry: Option<bool>,
}

impl TSStatus {
  pub fn new<F2, F3, F4, F5>(code: i32, message: F2, sub_status: F3, redirect_node: F4, need_retry: F5) -> TSStatus where F2: Into<Option<String>>, F3: Into<Option<Vec<Box<TSStatus>>>>, F4: Into<Option<TEndPoint>>, F5: Into<Option<bool>> {
    TSStatus {
      code,
      message: message.into(),
      sub_status: sub_status.into(),
      redirect_node: redirect_node.into(),
      need_retry: need_retry.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<Box<TSStatus>>> = None;
    let mut f_4: Option<TEndPoint> = None;
    let mut f_5: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TSStatus>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = Box::new(TSStatus::read_from_in_protocol(i_prot)?);
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSStatus.code", &f_1)?;
    let ret = TSStatus {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message: f_2,
      sub_status: f_3,
      redirect_node: f_4,
      need_retry: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::I32, 1))?;
    o_prot.write_i32(self.code)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sub_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("subStatus", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.redirect_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("redirectNode", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.need_retry {
      o_prot.write_field_begin(&TFieldIdentifier::new("needRetry", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TConsensusGroupId
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TConsensusGroupId {
  pub type_: TConsensusGroupType,
  pub id: i32,
}

impl TConsensusGroupId {
  pub fn new(type_: TConsensusGroupType, id: i32) -> TConsensusGroupId {
    TConsensusGroupId {
      type_,
      id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TConsensusGroupId> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TConsensusGroupType> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TConsensusGroupType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TConsensusGroupId.type_", &f_1)?;
    verify_required_field_exists("TConsensusGroupId.id", &f_2)?;
    let ret = TConsensusGroupId {
      type_: f_1.expect("auto-generated code should have checked for presence of required fields"),
      id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TConsensusGroupId");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 1))?;
    self.type_.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I32, 2))?;
    o_prot.write_i32(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSeriesPartitionSlot
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSeriesPartitionSlot {
  pub slot_id: i32,
}

impl TSeriesPartitionSlot {
  pub fn new(slot_id: i32) -> TSeriesPartitionSlot {
    TSeriesPartitionSlot {
      slot_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSeriesPartitionSlot> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSeriesPartitionSlot.slot_id", &f_1)?;
    let ret = TSeriesPartitionSlot {
      slot_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSeriesPartitionSlot");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("slotId", TType::I32, 1))?;
    o_prot.write_i32(self.slot_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TTimePartitionSlot
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTimePartitionSlot {
  pub start_time: i64,
}

impl TTimePartitionSlot {
  pub fn new(start_time: i64) -> TTimePartitionSlot {
    TTimePartitionSlot {
      start_time,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTimePartitionSlot> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTimePartitionSlot.start_time", &f_1)?;
    let ret = TTimePartitionSlot {
      start_time: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTimePartitionSlot");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startTime", TType::I64, 1))?;
    o_prot.write_i64(self.start_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TRegionReplicaSet
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TRegionReplicaSet {
  pub region_id: TConsensusGroupId,
  pub data_node_locations: Vec<Box<TDataNodeLocation>>,
}

impl TRegionReplicaSet {
  pub fn new(region_id: TConsensusGroupId, data_node_locations: Vec<Box<TDataNodeLocation>>) -> TRegionReplicaSet {
    TRegionReplicaSet {
      region_id,
      data_node_locations,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TRegionReplicaSet> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TConsensusGroupId> = None;
    let mut f_2: Option<Vec<Box<TDataNodeLocation>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TConsensusGroupId::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TDataNodeLocation>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = Box::new(TDataNodeLocation::read_from_in_protocol(i_prot)?);
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TRegionReplicaSet.region_id", &f_1)?;
    verify_required_field_exists("TRegionReplicaSet.data_node_locations", &f_2)?;
    let ret = TRegionReplicaSet {
      region_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      data_node_locations: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TRegionReplicaSet");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("regionId", TType::Struct, 1))?;
    self.region_id.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataNodeLocations", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.data_node_locations.len() as i32))?;
    for e in &self.data_node_locations {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TNodeResource
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TNodeResource {
  pub cpu_core_num: i32,
  pub max_memory: i64,
}

impl TNodeResource {
  pub fn new(cpu_core_num: i32, max_memory: i64) -> TNodeResource {
    TNodeResource {
      cpu_core_num,
      max_memory,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TNodeResource> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TNodeResource.cpu_core_num", &f_1)?;
    verify_required_field_exists("TNodeResource.max_memory", &f_2)?;
    let ret = TNodeResource {
      cpu_core_num: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_memory: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TNodeResource");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cpuCoreNum", TType::I32, 1))?;
    o_prot.write_i32(self.cpu_core_num)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxMemory", TType::I64, 2))?;
    o_prot.write_i64(self.max_memory)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TConfigNodeLocation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TConfigNodeLocation {
  pub config_node_id: i32,
  pub internal_end_point: TEndPoint,
  pub consensus_end_point: TEndPoint,
}

impl TConfigNodeLocation {
  pub fn new(config_node_id: i32, internal_end_point: TEndPoint, consensus_end_point: TEndPoint) -> TConfigNodeLocation {
    TConfigNodeLocation {
      config_node_id,
      internal_end_point,
      consensus_end_point,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TConfigNodeLocation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<TEndPoint> = None;
    let mut f_3: Option<TEndPoint> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TConfigNodeLocation.config_node_id", &f_1)?;
    verify_required_field_exists("TConfigNodeLocation.internal_end_point", &f_2)?;
    verify_required_field_exists("TConfigNodeLocation.consensus_end_point", &f_3)?;
    let ret = TConfigNodeLocation {
      config_node_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      internal_end_point: f_2.expect("auto-generated code should have checked for presence of required fields"),
      consensus_end_point: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TConfigNodeLocation");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("configNodeId", TType::I32, 1))?;
    o_prot.write_i32(self.config_node_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("internalEndPoint", TType::Struct, 2))?;
    self.internal_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("consensusEndPoint", TType::Struct, 3))?;
    self.consensus_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDataNodeLocation
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDataNodeLocation {
  pub data_node_id: i32,
  pub client_rpc_end_point: TEndPoint,
  pub internal_end_point: TEndPoint,
  pub m_p_p_data_exchange_end_point: TEndPoint,
  pub data_region_consensus_end_point: TEndPoint,
  pub schema_region_consensus_end_point: TEndPoint,
}

impl TDataNodeLocation {
  pub fn new(data_node_id: i32, client_rpc_end_point: TEndPoint, internal_end_point: TEndPoint, m_p_p_data_exchange_end_point: TEndPoint, data_region_consensus_end_point: TEndPoint, schema_region_consensus_end_point: TEndPoint) -> TDataNodeLocation {
    TDataNodeLocation {
      data_node_id,
      client_rpc_end_point,
      internal_end_point,
      m_p_p_data_exchange_end_point,
      data_region_consensus_end_point,
      schema_region_consensus_end_point,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataNodeLocation> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<TEndPoint> = None;
    let mut f_3: Option<TEndPoint> = None;
    let mut f_4: Option<TEndPoint> = None;
    let mut f_5: Option<TEndPoint> = None;
    let mut f_6: Option<TEndPoint> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = TEndPoint::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TDataNodeLocation.data_node_id", &f_1)?;
    verify_required_field_exists("TDataNodeLocation.client_rpc_end_point", &f_2)?;
    verify_required_field_exists("TDataNodeLocation.internal_end_point", &f_3)?;
    verify_required_field_exists("TDataNodeLocation.m_p_p_data_exchange_end_point", &f_4)?;
    verify_required_field_exists("TDataNodeLocation.data_region_consensus_end_point", &f_5)?;
    verify_required_field_exists("TDataNodeLocation.schema_region_consensus_end_point", &f_6)?;
    let ret = TDataNodeLocation {
      data_node_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_rpc_end_point: f_2.expect("auto-generated code should have checked for presence of required fields"),
      internal_end_point: f_3.expect("auto-generated code should have checked for presence of required fields"),
      m_p_p_data_exchange_end_point: f_4.expect("auto-generated code should have checked for presence of required fields"),
      data_region_consensus_end_point: f_5.expect("auto-generated code should have checked for presence of required fields"),
      schema_region_consensus_end_point: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDataNodeLocation");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataNodeId", TType::I32, 1))?;
    o_prot.write_i32(self.data_node_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientRpcEndPoint", TType::Struct, 2))?;
    self.client_rpc_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("internalEndPoint", TType::Struct, 3))?;
    self.internal_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mPPDataExchangeEndPoint", TType::Struct, 4))?;
    self.m_p_p_data_exchange_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataRegionConsensusEndPoint", TType::Struct, 5))?;
    self.data_region_consensus_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schemaRegionConsensusEndPoint", TType::Struct, 6))?;
    self.schema_region_consensus_end_point.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TDataNodeConfiguration
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TDataNodeConfiguration {
  pub location: TDataNodeLocation,
  pub resource: TNodeResource,
}

impl TDataNodeConfiguration {
  pub fn new(location: TDataNodeLocation, resource: TNodeResource) -> TDataNodeConfiguration {
    TDataNodeConfiguration {
      location,
      resource,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TDataNodeConfiguration> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TDataNodeLocation> = None;
    let mut f_2: Option<TNodeResource> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TDataNodeLocation::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TNodeResource::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TDataNodeConfiguration.location", &f_1)?;
    verify_required_field_exists("TDataNodeConfiguration.resource", &f_2)?;
    let ret = TDataNodeConfiguration {
      location: f_1.expect("auto-generated code should have checked for presence of required fields"),
      resource: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TDataNodeConfiguration");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("location", TType::Struct, 1))?;
    self.location.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resource", TType::Struct, 2))?;
    self.resource.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFlushReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFlushReq {
  pub is_seq: Option<String>,
  pub storage_groups: Option<Vec<String>>,
}

impl TFlushReq {
  pub fn new<F1, F2>(is_seq: F1, storage_groups: F2) -> TFlushReq where F1: Into<Option<String>>, F2: Into<Option<Vec<String>>> {
    TFlushReq {
      is_seq: is_seq.into(),
      storage_groups: storage_groups.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFlushReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_string()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TFlushReq {
      is_seq: f_1,
      storage_groups: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFlushReq");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.is_seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("isSeq", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.storage_groups {
      o_prot.write_field_begin(&TFieldIdentifier::new("storageGroups", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TFlushReq {
  fn default() -> Self {
    TFlushReq{
      is_seq: Some("".to_owned()),
      storage_groups: Some(Vec::new()),
    }
  }
}

//
// TSettleReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSettleReq {
  pub paths: Vec<String>,
}

impl TSettleReq {
  pub fn new(paths: Vec<String>) -> TSettleReq {
    TSettleReq {
      paths,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSettleReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = i_prot.read_string()?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSettleReq.paths", &f_1)?;
    let ret = TSettleReq {
      paths: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSettleReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paths", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.paths.len() as i32))?;
    for e in &self.paths {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSchemaNode
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSchemaNode {
  pub node_name: String,
  pub node_type: i8,
}

impl TSchemaNode {
  pub fn new(node_name: String, node_type: i8) -> TSchemaNode {
    TSchemaNode {
      node_name,
      node_type,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSchemaNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i8> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i8()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSchemaNode.node_name", &f_1)?;
    verify_required_field_exists("TSchemaNode.node_type", &f_2)?;
    let ret = TSchemaNode {
      node_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      node_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSchemaNode");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nodeName", TType::String, 1))?;
    o_prot.write_string(&self.node_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nodeType", TType::I08, 2))?;
    o_prot.write_i8(self.node_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSetTTLReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSetTTLReq {
  pub storage_group_path_pattern: Vec<String>,
  pub t_t_l: i64,
}

impl TSetTTLReq {
  pub fn new(storage_group_path_pattern: Vec<String>, t_t_l: i64) -> TSetTTLReq {
    TSetTTLReq {
      storage_group_path_pattern,
      t_t_l,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSetTTLReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = i_prot.read_string()?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSetTTLReq.storage_group_path_pattern", &f_1)?;
    verify_required_field_exists("TSetTTLReq.t_t_l", &f_2)?;
    let ret = TSetTTLReq {
      storage_group_path_pattern: f_1.expect("auto-generated code should have checked for presence of required fields"),
      t_t_l: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSetTTLReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("storageGroupPathPattern", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.storage_group_path_pattern.len() as i32))?;
    for e in &self.storage_group_path_pattern {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("TTL", TType::I64, 2))?;
    o_prot.write_i64(self.t_t_l)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFile
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFile {
  pub file_name: String,
  pub file: Vec<u8>,
}

impl TFile {
  pub fn new(file_name: String, file: Vec<u8>) -> TFile {
    TFile {
      file_name,
      file,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFile> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TFile.file_name", &f_1)?;
    verify_required_field_exists("TFile.file", &f_2)?;
    let ret = TFile {
      file_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      file: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFile");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fileName", TType::String, 1))?;
    o_prot.write_string(&self.file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("file", TType::String, 2))?;
    o_prot.write_bytes(&self.file)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TFilesResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TFilesResp {
  pub status: TSStatus,
  pub files: Vec<TFile>,
}

impl TFilesResp {
  pub fn new(status: TSStatus, files: Vec<TFile>) -> TFilesResp {
    TFilesResp {
      status,
      files,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TFilesResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSStatus> = None;
    let mut f_2: Option<Vec<TFile>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TFile> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = TFile::read_from_in_protocol(i_prot)?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TFilesResp.status", &f_1)?;
    verify_required_field_exists("TFilesResp.files", &f_2)?;
    let ret = TFilesResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      files: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TFilesResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("files", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, self.files.len() as i32))?;
    for e in &self.files {
      e.write_to_out_protocol(o_prot)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSpaceQuota
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSpaceQuota {
  pub disk_size: Option<i64>,
  pub device_num: Option<i64>,
  pub timeserie_num: Option<i64>,
}

impl TSpaceQuota {
  pub fn new<F1, F2, F3>(disk_size: F1, device_num: F2, timeserie_num: F3) -> TSpaceQuota where F1: Into<Option<i64>>, F2: Into<Option<i64>>, F3: Into<Option<i64>> {
    TSpaceQuota {
      disk_size: disk_size.into(),
      device_num: device_num.into(),
      timeserie_num: timeserie_num.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSpaceQuota> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSpaceQuota {
      disk_size: f_1,
      device_num: f_2,
      timeserie_num: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSpaceQuota");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.disk_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("diskSize", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.device_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("deviceNum", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.timeserie_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeserieNum", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TSpaceQuota {
  fn default() -> Self {
    TSpaceQuota{
      disk_size: Some(0),
      device_num: Some(0),
      timeserie_num: Some(0),
    }
  }
}

//
// TTimedQuota
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TTimedQuota {
  pub time_unit: i64,
  pub soft_limit: i64,
}

impl TTimedQuota {
  pub fn new(time_unit: i64, soft_limit: i64) -> TTimedQuota {
    TTimedQuota {
      time_unit,
      soft_limit,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TTimedQuota> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TTimedQuota.time_unit", &f_1)?;
    verify_required_field_exists("TTimedQuota.soft_limit", &f_2)?;
    let ret = TTimedQuota {
      time_unit: f_1.expect("auto-generated code should have checked for presence of required fields"),
      soft_limit: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TTimedQuota");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeUnit", TType::I64, 1))?;
    o_prot.write_i64(self.time_unit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("softLimit", TType::I64, 2))?;
    o_prot.write_i64(self.soft_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TThrottleQuota
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TThrottleQuota {
  pub throttle_limit: Option<BTreeMap<ThrottleType, TTimedQuota>>,
  pub mem_limit: Option<i64>,
  pub cpu_limit: Option<i32>,
}

impl TThrottleQuota {
  pub fn new<F1, F2, F3>(throttle_limit: F1, mem_limit: F2, cpu_limit: F3) -> TThrottleQuota where F1: Into<Option<BTreeMap<ThrottleType, TTimedQuota>>>, F2: Into<Option<i64>>, F3: Into<Option<i32>> {
    TThrottleQuota {
      throttle_limit: throttle_limit.into(),
      mem_limit: mem_limit.into(),
      cpu_limit: cpu_limit.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TThrottleQuota> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<ThrottleType, TTimedQuota>> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<ThrottleType, TTimedQuota> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_6 = ThrottleType::read_from_in_protocol(i_prot)?;
            let map_val_7 = TTimedQuota::read_from_in_protocol(i_prot)?;
            val.insert(map_key_6, map_val_7);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TThrottleQuota {
      throttle_limit: f_1,
      mem_limit: f_2,
      cpu_limit: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TThrottleQuota");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.throttle_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("throttleLimit", TType::Map, 1))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        k.write_to_out_protocol(o_prot)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.mem_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("memLimit", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.cpu_limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("cpuLimit", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TThrottleQuota {
  fn default() -> Self {
    TThrottleQuota{
      throttle_limit: Some(BTreeMap::new()),
      mem_limit: Some(0),
      cpu_limit: Some(0),
    }
  }
}

//
// TSetSpaceQuotaReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSetSpaceQuotaReq {
  pub database: Vec<String>,
  pub space_limit: TSpaceQuota,
}

impl TSetSpaceQuotaReq {
  pub fn new(database: Vec<String>, space_limit: TSpaceQuota) -> TSetSpaceQuotaReq {
    TSetSpaceQuotaReq {
      database,
      space_limit,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSetSpaceQuotaReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<TSpaceQuota> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = i_prot.read_string()?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TSpaceQuota::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSetSpaceQuotaReq.database", &f_1)?;
    verify_required_field_exists("TSetSpaceQuotaReq.space_limit", &f_2)?;
    let ret = TSetSpaceQuotaReq {
      database: f_1.expect("auto-generated code should have checked for presence of required fields"),
      space_limit: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSetSpaceQuotaReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("database", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.database.len() as i32))?;
    for e in &self.database {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spaceLimit", TType::Struct, 2))?;
    self.space_limit.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSetThrottleQuotaReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSetThrottleQuotaReq {
  pub user_name: String,
  pub throttle_quota: TThrottleQuota,
}

impl TSetThrottleQuotaReq {
  pub fn new(user_name: String, throttle_quota: TThrottleQuota) -> TSetThrottleQuotaReq {
    TSetThrottleQuotaReq {
      user_name,
      throttle_quota,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSetThrottleQuotaReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<TThrottleQuota> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = TThrottleQuota::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSetThrottleQuotaReq.user_name", &f_1)?;
    verify_required_field_exists("TSetThrottleQuotaReq.throttle_quota", &f_2)?;
    let ret = TSetThrottleQuotaReq {
      user_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      throttle_quota: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSetThrottleQuotaReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userName", TType::String, 1))?;
    o_prot.write_string(&self.user_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("throttleQuota", TType::Struct, 2))?;
    self.throttle_quota.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TLicense
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TLicense {
  pub license_issue_timestamp: i64,
  pub expire_timestamp: i64,
  pub data_node_num_limit: i16,
  pub cpu_core_num_limit: i32,
  pub device_num_limit: i64,
  pub sensor_num_limit: i64,
  pub disconnection_from_active_node_time_limit: i64,
  pub ml_node_num_limit: i16,
}

impl TLicense {
  pub fn new(license_issue_timestamp: i64, expire_timestamp: i64, data_node_num_limit: i16, cpu_core_num_limit: i32, device_num_limit: i64, sensor_num_limit: i64, disconnection_from_active_node_time_limit: i64, ml_node_num_limit: i16) -> TLicense {
    TLicense {
      license_issue_timestamp,
      expire_timestamp,
      data_node_num_limit,
      cpu_core_num_limit,
      device_num_limit,
      sensor_num_limit,
      disconnection_from_active_node_time_limit,
      ml_node_num_limit,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TLicense> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_4: Option<i16> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<i16> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        4 => {
          let val = i_prot.read_i16()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i16()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TLicense.license_issue_timestamp", &f_1)?;
    verify_required_field_exists("TLicense.expire_timestamp", &f_2)?;
    verify_required_field_exists("TLicense.data_node_num_limit", &f_4)?;
    verify_required_field_exists("TLicense.cpu_core_num_limit", &f_5)?;
    verify_required_field_exists("TLicense.device_num_limit", &f_6)?;
    verify_required_field_exists("TLicense.sensor_num_limit", &f_7)?;
    verify_required_field_exists("TLicense.disconnection_from_active_node_time_limit", &f_8)?;
    verify_required_field_exists("TLicense.ml_node_num_limit", &f_9)?;
    let ret = TLicense {
      license_issue_timestamp: f_1.expect("auto-generated code should have checked for presence of required fields"),
      expire_timestamp: f_2.expect("auto-generated code should have checked for presence of required fields"),
      data_node_num_limit: f_4.expect("auto-generated code should have checked for presence of required fields"),
      cpu_core_num_limit: f_5.expect("auto-generated code should have checked for presence of required fields"),
      device_num_limit: f_6.expect("auto-generated code should have checked for presence of required fields"),
      sensor_num_limit: f_7.expect("auto-generated code should have checked for presence of required fields"),
      disconnection_from_active_node_time_limit: f_8.expect("auto-generated code should have checked for presence of required fields"),
      ml_node_num_limit: f_9.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TLicense");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("licenseIssueTimestamp", TType::I64, 1))?;
    o_prot.write_i64(self.license_issue_timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("expireTimestamp", TType::I64, 2))?;
    o_prot.write_i64(self.expire_timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataNodeNumLimit", TType::I16, 4))?;
    o_prot.write_i16(self.data_node_num_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cpuCoreNumLimit", TType::I32, 5))?;
    o_prot.write_i32(self.cpu_core_num_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deviceNumLimit", TType::I64, 6))?;
    o_prot.write_i64(self.device_num_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sensorNumLimit", TType::I64, 7))?;
    o_prot.write_i64(self.sensor_num_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("disconnectionFromActiveNodeTimeLimit", TType::I64, 8))?;
    o_prot.write_i64(self.disconnection_from_active_node_time_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("mlNodeNumLimit", TType::I16, 9))?;
    o_prot.write_i16(self.ml_node_num_limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

